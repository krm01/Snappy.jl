# Snappy.jl
[![Build Status](https://travis-ci.org/krm01/Snappy.jl.svg?branch=master)](https://travis-ci.org/krm01/Snappy.jl)
[![Build status](https://ci.appveyor.com/api/projects/status/vhvheji9o932cjde?svg=true)](https://ci.appveyor.com/project/krm01/snappy-jl)
[![codecov](https://codecov.io/gh/krm01/Snappy.jl/branch/master/graph/badge.svg)](https://codecov.io/gh/krm01/Snappy.jl)

Julia implementation of the snappy compressor <https://github.com/google/snappy>, a fast compression library developed by Google.

An alternative package is available at <https://github.com/bicycle1885/Snappy.jl>, which provides a lightweight Julia wrapper for the above C++ binary.

## Usage
The compression and decompression functions operate on and return byte arrays, i.e. `Vector{UInt8}`. Two functions are exported:

```julia
compress(input::Vector{UInt8})
```
```julia
uncompress(input::Vector{UInt8})
```
A `compress(input::String)` method is provided for convenience.

## Performance
This Julia implementation produces nearly identical compressed output compared to the reference C++ version, typically within `0.01%` - e.g. for the `urls.10K` test file, Julia's output is `327.575KiB` compared to C++'s `327.526KiB`.

Currently, Julia is ≈ 20% faster for compression, but ≈ 60% _slower_ for decompression on compressible input. The decompression routine in Julia is not as quick with handling copy backreferences, but there is likely plenty of room for improvement there.

The table below is created from data generated by the `test/benchmarks.jl` script. The file `src/libsnappy.jl` implements the `ccall` to the libsnappy library, and was used in the benchmarks below. The time reported is the median of 10,000 samples (except for the `large` entry, which is built from the linux kernel source code - only 100 samples were taken).


|file|size|Julia (compress)|ccall (compress)| ∆ |Julia (uncompress)|ccall (uncompress)| ∆ |
|----|---|:------------:|:------------:|---|:-----------:|:-----------:|---|
|`txt`|149K|580 μs|756 μs|<span style="color:green">-23.30%</span>|247 μs|220 μs|<span style="color:red">+12.41%</span>|
|`html`|100K|145 μs|193 μs|<span style="color:green">-25.09%</span>|116 μs|56.4 μs|<span style="color:red">+103.78%</span>|
|`jpeg`|120K|65 μs|65 μs|-0.00%|17 μs|17 μs|+0.00%|
|`pdf`|100K|70 μs|76 μs|<span style="color:green">-7.24%</span>|37 μs|20 μs|<span style="color:red">+88.17%</span>|
|`urls`|686K|1.68 ms|2.11 ms|<span style="color:green">-20.42%</span>|982 μs|727 μs|<span style="color:red">+40.73%</span>|
|`json`|13K|16 μs|20 μs|<span style="color:green">-15.82%</span>|12 μs|5.4 μs|<span style="color:red">+135.49%</span>|
|`large`|6597K|1.76 s|2.31 s|<span style="color:green">-23.69%</span>|1.02 s|773 ms|<span style="color:red">+31.86%</span>|

Tests were run with Julia 0.6.0 on 64-bit Mac OS.

The compression/decompression routines are optimized to target 64-bit little endian systems, and will likely run slower on other platforms.




